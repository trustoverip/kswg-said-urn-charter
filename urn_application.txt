Namespace Registration for Self-Addressing Identifiers (SAID)

Namespace Identifier:  said

Version:  1

Date:  2025-09-25

Registrant: Sam Smith, Wenjing Chu, Carly Huitema
on behalf of ToIP (Trust over IP), a project of the Linux Foundation Decentralized Trust
https://trustoverip.org/
Contact email: (Wenjing Chu) trustoverip@lfdecentralizedtrust.org

Purpose: 

Self-Addressing Identifiers (SAIDs) are self-referential content-addressable identifiers based on Composable Event Streaming Representation (CESR) [1] encoded cryptographic digest. This proposal defines a method to unambiguously identify digital assets that contain their SAIDs via their SAID identifiers in the urn:said namespace. Such urn:said identifiers can ease the ways of adopting SAIDs anywhere URNs are accepted and improve interoperability. These URNs are typically non-resolvable, serving as unique identifiers. However, optional mechanisms could be introduced in the future in addressing such requirements.

Syntax:

A `said` URN shall consist of two mandatory components in the following order, with `:` characters between each section.
 
  - URN identifier (`urn:said`): REQUIRED

  - SAID, in string representation as per Composable Event Streaming Representation (CESR) [1], Section 11.6 and represented with Base64URLSafe alphabet of RFC 4648 (with the exception of `=` pad character which is not used in CESR). REQUIRED

The ABNF of an `said` URN MUST be as follows:

```ABNF
said-urn = "urn:said:" said

said = cesr-code cesr-digest-value

cesr-code = <CESR type code identifying the digest algorithm>

cesr-digest-value = <Base64URLSafe encoded digest, length determined by cesr-code>

; Base64URLSafe characters (RFC 4648, excluding padding)
base64urlsafe = ALPHA / DIGIT / "-" / "_"

; The complete said primitive MUST conform to CESR code table [2], CESR spec Section 11.4.
; The following currently defined digest codes, for example, produce SAIDs of 44 or 88 characters total.
;
; 256-bit SAIDs: 44 characters total (1 char code + 43 Base64URLSafe)
; one-char-code = "E" / "F" / "G" / "H" / "I"
; said-256 = one-char-code 43base64urlsafe

; 512-bit SAIDs: 88 characters total (2 char code + 86 Base64URLSafe)
; two-char-code = "0D" / "0E" / "0F" / "0G"
; said-512 = two-char-code 86base64urlsafe
```

Examples:

  - `urn:said:E8wYuBjhslETYaLZcxMkWrhVbMcA8RS1pKYl7nJ77ntA` (44 characters, Blake3-256)
  - `urn:said:0FCNcm3MGi3efpdqsmmzGU2tnEPpAndgeCQErutCuu82VfaZqc1BbxL0a2-fOrGilCK2XuHcMqtILo2nc7M2mUuw` (88 characters, SHA3-512)

The first example is 44 characters long in text representation, where `E` indicates Blake3-256 digest and the remaining 43 characters encode 256 bit digest. The second example has a two character code `0F`, followed by 86 characters encoding 512 bit SHA3-512 digest. Additional digest functions are listed in CESR Spec code table, Section 11.4.2 [2].

Assignment: 

The SAID strings conforming to this scheme are self-assigned, based on the derivation of the SAID as per CESR Spec [1]. 

CESR (Composable Event Streaming Representation) is a dual text-binary encoding format providing lossless round-trip conversion between text (Base64URLSafe) and binary domains. CESR primitives are self-framing: each primitive includes a prepended type code identifying both the cryptographic algorithm and value length, enabling stream parsing without external delimiters. A Self-Addressing Identifier (SAID) is derived by: (1) designating a location within the data for the SAID, (2) inserting a placeholder of the appropriate length at that location, (3) computing a cryptographic digest over the entire byte sequence, and (4) replacing the placeholder with the CESR-encoded digest. The placeholder length equals the final SAID length: 33 bytes in the binary domain or 44 characters in the text domain for a 256-bit digest. Verification reverses this process. The CESR type code (e.g., E for Blake3-256) makes the digest algorithm self-describing, providing cryptographic agility.

The digital assets identified by an `urn:said` identifier must contain the SAID identifier in itself (i.e. self-referential). The SAID derivation procedure defined by CESR Spec [1] (Section 11.6) requires a consistent serialization scheme for the digital assets in order for correct representation and verification. In other words, SAID identifies the serialization of the digital assets where it is also contained.

The serialization scheme used for SAID derivation must be known to verifiers. This is typically established by the application context or protocol in which the SAID appears. The serialization scheme information is not encoded in the SAID. Note that applications can choose their own serialization schemes, but for reproducibility and verification, the chosen scheme must preserve the size and order of data fields in the structure. For interoperability over a network, standardized serialization methods such as JSON, CBOR, MessagePack, as well as native CESR can be used.

To illustrate, here are some examples of how the derivation works (from CESR [1], Section 11.6):

(1) Python dict data structure (Python 3.6 or later where dict is order preserving)

Suppose the initial value of Python dict data structure is as follows:
{
    "said": "",
    "first": "Sue",
    "last": "Smith",
    "role": "Founder"
}

If we choose the 44 CESR character Blake3-256 digest for SAID derivation and use JSON serialization, the first of the derivation procedure is to insert the `#` character in place of the future SAID string:
{
    "said": "############################################",
    "first": "Sue",
    "last": "Smith",
    "role": "Founder"
}

For consistent serialization, we remove all extra white space:
{"said":"############################################","first":"Sue","last":"Smith","role":"Founder"}

Apply Blake3-256 digest algorithm to this representation, we obtain the SAID (encoded in CESR) string (in text format):
EJymtAC4piy_HkHWRs4JSRv0sb53MZJr8BQ4SMixXIVJ

Now, replace the `#` spaceholder with the SAID string, the data asset with the SAID becomes:
{"said":"EJymtAC4piy_HkHWRs4JSRv0sb53MZJr8BQ4SMixXIVJ","first":"Sue","last":"Smith","role":"Founder"}

The URN for the above data representation is:
`urn:said:EJymtAC4piy_HkHWRs4JSRv0sb53MZJr8BQ4SMixXIVJ`

Now, the Python data structure may be updated to:
{
    "said": "EJymtAC4piy_HkHWRs4JSRv0sb53MZJr8BQ4SMixXIVJ",
    "first": "Sue",
    "last": "Smith",
    "role": "Founder"
}

It is important to note that verification of SAID (therefore `urn:said`) must be performed on the consistent serialization format of the digital asset.

Security and Privacy: 

`urn:said` identifiers are designed to identify digital assets. Do not assume they are random or hard to guess. In fact, if the digital content itself is known they can be deterministically derived for a given digest algorithm. Such identifiers, therefore, should not be naively used for security capabilities (identifiers whose mere possesion grants privileged access).

The SAID must be encoded with one of the digest algorithms provided in the CESR code tables, as defined in Section 11.1 of CESR 2.0 specification (which may be viewed as the security considerations for SAID). This normative requirement is that cryptographic primitives that are entered in the table must maintain 128 bits of cryptographic strength. This strength protects against attempts to alter the binding between a `urn:said` identifier and its self-referenced content. Additional digest algorithms may be added to the code table in the future, e.g. for approved NIST post-quantum resistant cryptographic operations.

Adding `urn:said` identifier to the self-referenced digital asset does not change privacy considerations.

Interoperability: 

A SAID string MUST be CESR encoded which self-identifies the digest algorithm used to generate it. This greatly enhances interoperability and future adaptability. In addition, the use of CESR encoding allows lossless transformation between binary and text domains. This property is useful in digital assets which may be most optimally represented in binary or serialization schemes such as CBOR.

Adopters MAY consider narrowing selections of digest functions to reduce complexity and improve interoperability with some cost in flexibility.

Resolution:

These URNs are non-resolvable and serve as globally unique identifiers. In future, however, we may extend this scheme with optional information for easier resolution.

Documentation: 

- [1] CESR: omposable Event Streaming Representation, https://trustoverip.github.io/kswg-cesr-specification
- [2] CESR Code Table: Composable Event Streaming Representation (CESR) Genus AAA, the latest code table (the current version at the time of this application: CAA, i.e. 2.0), https://trustoverip.github.io/kswg-cesr-specification/#keriacdc-protocol-genus-version-table
- [3] RFC 4648: The Base16, Base32, and Base64 Data Encodings, https://datatracker.ietf.org/doc/html/rfc4648

Additional Information:  NONE

Revision Information:  N/A

